plugins {
	id 'fabric-loom' version '1.11-SNAPSHOT'
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

loom {
	accessWidenerPath = file("src/main/resources/cubliminal.accesswidener")
}

repositories {
	mavenCentral()
	maven {
		url = "https://maven2.fabricmc.net"
	}
	maven {
		url = "https://jitpack.io"
	}
	maven {
		url "https://maven.shedaniel.me/"
	}
	maven {
		url "https://maven.nucleoid.xyz/"
	}
	maven {
		url "https://maven.terraformersmc.com/releases/"
	}
	maven {
		url 'https://api.modrinth.com/maven'
		content {
			includeGroup "maven.modrinth"
		}
	}
}

fabricApi {
	configureDataGeneration()
}

dependencies {
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

	includeMod("com.github.jdiemke.delaunay-triangulator:DelaunayTriangulator:${project.triangulator_version}")
	includeMod("me.shedaniel.cloth:cloth-config-fabric:${project.cloth_version}")
	modImplementation("com.terraformersmc:modmenu:${project.modmenu_version}")

	//includeMod("com.github.northernlimit:Special-Models-Fabric:${project.specialmodels_version}")
	includeMod("com.github.northernlimit:Liminal-Library-Fabric:${project.limlib_version}")
}
def includeMod(var dep) {
	dependencies.modImplementation(dep)
	dependencies.include(dep)
}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 21
}

java {
	withSourcesJar()

	sourceCompatibility = JavaVersion.VERSION_21
	targetCompatibility = JavaVersion.VERSION_21
}

jar {
	from("LICENSE") {
		rename { "${it}_${base.archivesName.get()}"}
	}
}

publishing {
	publications {
		create("mavenJava", MavenPublication) {
			artifactId = project.archives_base_name
			from components.java
		}
	}

	repositories {

	}
}

import groovy.json.JsonSlurper
import groovy.json.JsonOutput

import org.objectweb.asm.*

tasks.register('updateIniters') {
	dependsOn classes

	doLast {
		String initerClass = "net.limit.cubliminal.Initer"
		String initerClientClass = "net.limit.cubliminal.IniterClient"

		// Where compiled .class files live
		def classesDirs = sourceSets.main.output.classesDirs.files

		List<String> foundIniters = []
		List<String> foundClientIniters = []
		List<String> badConstructors = []   // <- keep track of offenders

		classesDirs.each { dir ->
			dir.eachFileRecurse { f ->
				if (!f.name.endsWith('.class')) return

				String className = dir.toPath()
						.relativize(f.toPath())
						.toString()
						.replace(File.separator, '.')
						.replaceAll(/\.class$/, '')

				try {
					def cr = new ClassReader(f.bytes)
					cr.accept(new ClassVisitor(Opcodes.ASM9) {
						boolean isIniter = false
						boolean isClientIniter = false
						boolean hasPublicNoArgCtor = false

						@Override
						void visit(int version, int access, String name,
								   String signature, String superName, String[] interfaces) {
							isIniter = interfaces.any { it.replace('/', '.') == initerClass }
							isClientIniter = interfaces.any { it.replace('/', '.') == initerClientClass }
						}

						@Override
						MethodVisitor visitMethod(int access, String name, String desc,
												  String sig, String[] exc) {
							if (name == "<init>" && desc == "()V"
									&& (access & Opcodes.ACC_PUBLIC) != 0) {
								hasPublicNoArgCtor = true
							}
							return super.visitMethod(access, name, desc, sig, exc)
						}

						@Override
						void visitEnd() {
							if (isIniter) {
								foundIniters << className
								if (!hasPublicNoArgCtor) {
									badConstructors << className
								}
							}
							if (isClientIniter) {
								foundClientIniters << className
								if (!hasPublicNoArgCtor) {
									badConstructors << className
								}
							}
						}
					}, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES)
				} catch (Throwable t) {
					println "Skipping $className due to parse error: ${t.message}"
				}
			}
		}

		/* ---------- fail if any bad constructors ---------- */
		if (!badConstructors.isEmpty()) {
			println "\n❌  The following classes implement Initer but lack a *public* no‑arg constructor:"
			badConstructors.each { println "   - $it" }
			def badActors = badConstructors.join(', ')
			throw new GradleException("Initer scan failed: $badActors")
		}

		/* ---------- write updated entrypoints ---------- */
		def modJsonFile = file('src/main/resources/fabric.mod.json')
		def modJson = new JsonSlurper().parseText(modJsonFile.text)

		modJson.entrypoints = modJson.entrypoints ?: [:]
		modJson.entrypoints.initer = foundIniters.sort()
		modJson.entrypoints.initerclient = foundClientIniters.sort()

		modJsonFile.text = JsonOutput.prettyPrint(
                JsonOutput.toJson(modJson))

		println "\n✅  Updated fabric.mod.json with ${foundIniters.size()} Initer implementations and ${foundClientIniters.size()} Client Initer implementations."
	}
}




